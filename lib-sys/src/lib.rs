/*  lib-sys | Rust bindings for lib-swiss, the Swiss Ephemeris C library.
 *  Copyright (c) 2024 Chinmay Vivek. All rights reserved.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

//! # lib-sys: Swiss Ephemeris Bindings in Rust
//!
//! This library provides Rust bindings for the Swiss Ephemeris, which allows for
//! high-precision calculations of planetary positions, ecliptic nutation, and
//! other astronomical phenomena. This library is primarily used in astrological
//! and astronomical applications.

#![allow(non_upper_case_globals, non_camel_case_types, non_snake_case)]

// Including the generated bindings from the Swiss Ephemeris C library.
// This file is generated by the `bindgen` tool during the build process.
include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

/// Test module to validate the functionality of the Swiss Ephemeris bindings.
///
/// This module contains unit tests to ensure that the library correctly interacts
/// with the Swiss Ephemeris functions and provides accurate results.
#[cfg(test)]
mod tests {
    use std::convert::TryInto;

    use super::*;

    /// Test to ensure that the Swiss Ephemeris library works correctly.
    ///
    /// The test sets the ephemeris path to the default (NULL) value, calculates the Julian day
    /// for a specific date, then iterates over planetary bodies to calculate their positions.
    /// It verifies correct calculation results and handles error messages when necessary.
    ///
    /// # Example
    ///
    /// This test will print the calculated coordinates for each planetary body:
    ///
    /// ```text
    /// Planet   lon     lat     dist
    /// 0        197.57  -0.0003 1.011
    /// 1        202.94  -0.0001 0.993
    /// 2        200.45  0.0051  1.057
    /// ```
    #[test]
    fn it_works() {
        unsafe {
            // Set the ephemeris path to null (use default path).
            let null: *mut i8 = std::ptr::null_mut();
            swe_set_ephe_path(null);

            // Convert SEFLG_TROPICAL flag to i32 for the calculation.
            let iflag: i32 = SEFLG_TROPICAL.try_into().unwrap();

            // Convert SE_GREG_CAL flag to i32 for the Gregorian calendar.
            let gregorian_calendar_flag: i32 = SE_GREG_CAL.try_into().unwrap();

            // Calculate the Julian day for the date: 13th October 1991, 20:00 (UT).
            let julian_day_ut = swe_julday(1991, 10, 13, 20.0, gregorian_calendar_flag);

            // Array to hold calculated coordinates (longitude, latitude, distance).
            let mut coordinates: [f64; 6] = [0.0; 6];

            // Array to hold the name of the planet.
            let mut name: [u8; 64] = [0; 64];

            // Array to hold error messages in case of failure.
            let mut error_message: [u8; 256] = [0; 256];

            // Print header for the output.
            println!("Planet\tLongitude\tLatitude\tDistance");

            // Iterate through celestial bodies from SE_SUN to SE_CHIRON.
            for body in SE_SUN..SE_CHIRON {
                // Skip the Earth as it is not relevant for these calculations.
                if body == SE_EARTH {
                    continue;
                }

                // Convert the body constant to i32 for the calculation.
                let body_signed: i32 = body.try_into().unwrap();

                // Perform the calculation for the celestial body.
                let return_flag = swe_calc_ut(
                    julian_day_ut,
                    body_signed,
                    iflag,
                    coordinates.as_mut_ptr(),
                    error_message.as_mut_ptr() as *mut i8,
                );

                // Check if the calculation was successful.
                if return_flag < 0 {
                    // If there was an error, convert the error message to a string and print it.
                    let error_vec: Vec<u8> = error_message.clone().as_ref().into();
                    let error_string = String::from_utf8_unchecked(error_vec);
                    eprintln!("Error: {}", error_string);
                } else {
                    // If successful, get the name of the planet.
                    swe_get_planet_name(body_signed, name.as_mut_ptr() as *mut i8);

                    // Convert the name to a Rust string.
                    let name_str = String::from_utf8_lossy(&name);

                    // Print the planet name along with its calculated coordinates.
                    println!(
                        "{}\t{}\t{}\t{}",
                        name_str.trim_end_matches(char::from(0)),
                        coordinates[0], // Longitude
                        coordinates[1], // Latitude
                        coordinates[2]  // Distance
                    );
                }
            }

            // Close the Swiss Ephemeris to clean up resources.
            swe_close();
        }
    }
}
